#!/usr/bin/env python3
"""
Word Exporter for YMYL Audit Tool

Converts markdown reports to Microsoft Word documents with professional formatting.
This rewritten version includes robust style handling, enhanced markdown parsing,
and dynamic page numbering.
"""

import io
import re
from typing import Optional, List
from docx import Document
from docx.shared import Inches, RGBColor, Pt
from docx.enum.style import WD_STYLE_TYPE
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from docx.oxml import OxmlElement
from utils.logging_utils import setup_logger

logger = setup_logger(__name__)


class WordExporter:
    """
    Converts markdown reports to professionally formatted Word documents.

    Features:
    - Professional document styling with conflict-free style creation.
    - Enhanced markdown parser for paragraphs, lists, tables, and inline styles.
    - Table of contents placeholder.
    - Color-coded severity indicators.
    - Dynamic page numbering in the footer.
    """

    def __init__(self):
        """Initialize the Word exporter."""
        logger.info("WordExporter initialized")

    def convert(self, markdown_content: str, title: str = "YMYL Compliance Audit Report") -> bytes:
        """
        Converts markdown content to a Word document in memory.

        Args:
            markdown_content (str): The markdown content to convert.
            title (str): The title of the document.

        Returns:
            bytes: The Word document as a byte stream.
        """
        if not self.validate_markdown(markdown_content):
            logger.error("Markdown validation failed. Aborting conversion.")
            return self._create_error_document("Invalid or empty markdown content provided.")

        try:
            logger.info(f"Converting markdown to Word document ({len(markdown_content):,} characters)")
            doc = Document()
            self._setup_document_properties(doc, title)
            self._create_custom_styles(doc)
            self._parse_and_add_content(doc, markdown_content, title)
            self._add_footer(doc)

            doc_buffer = io.BytesIO()
            doc.save(doc_buffer)
            doc_buffer.seek(0)

            logger.info("Word document conversion successful.")
            return doc_buffer.getvalue()

        except Exception as e:
            logger.error(f"Word conversion failed: {e}", exc_info=True)
            return self._create_error_document(str(e))

    def _setup_document_properties(self, doc: Document, title: str):
        """Sets the document's metadata properties."""
        properties = doc.core_properties
        properties.title = title
        properties.author = "YMYL Audit Tool"
        properties.subject = "YMYL Compliance Analysis Report"
        properties.category = "Compliance Report"
        properties.comments = "Generated by an AI-powered YMYL compliance analysis system."

    def _create_custom_styles(self, doc: Document):
        """
        Creates all necessary custom styles for the document, checking for
        existence first to prevent conflicts.
        """
        styles = doc.styles
        existing_styles = {s.name for s in styles}

        # Helper to create a style safely
        def add_style_if_not_exists(name, style_type, font_name, size, bold, color, align=None, space_before=None, space_after=None):
            if name not in existing_styles:
                style = styles.add_style(name, style_type)
                font = style.font
                font.name = font_name
                font.size = Pt(size)
                font.bold = bold
                font.color.rgb = RGBColor.from_string(color)
                p_fmt = style.paragraph_format
                if align:
                    p_fmt.alignment = align
                if space_before:
                    p_fmt.space_before = Pt(space_before)
                if space_after:
                    p_fmt.space_after = Pt(space_after)
                logger.debug(f"Created style '{name}'.")

        # Define styles
        add_style_if_not_exists('Report Title', WD_STYLE_TYPE.PARAGRAPH, 'Calibri', 24, True, '2C3E50', WD_ALIGN_PARAGRAPH.CENTER, space_after=18)
        add_style_if_not_exists('Section Heading', WD_STYLE_TYPE.PARAGRAPH, 'Calibri', 16, True, '34495E', space_before=12, space_after=6)
        add_style_if_not_exists('Subsection Heading', WD_STYLE_TYPE.PARAGRAPH, 'Calibri', 14, True, '34495E', space_before=8, space_after=4)
        
        # Severity Styles
        add_style_if_not_exists('Critical Severity', WD_STYLE_TYPE.CHARACTER, 'Calibri', 11, True, 'E74C3C')
        add_style_if_not_exists('High Severity', WD_STYLE_TYPE.CHARACTER, 'Calibri', 11, True, 'E67E22')
        add_style_if_not_exists('Medium Severity', WD_STYLE_TYPE.CHARACTER, 'Calibri', 11, True, 'F39C12')
        add_style_if_not_exists('Low Severity', WD_STYLE_TYPE.CHARACTER, 'Calibri', 11, True, '3498DB')

        # Content Styles
        add_style_if_not_exists('Processing Summary', WD_STYLE_TYPE.PARAGRAPH, 'Calibri', 10, False, '7F8C8D', space_before=6)
        add_style_if_not_exists('Code Block', WD_STYLE_TYPE.PARAGRAPH, 'Consolas', 10, False, '2C3E50')

    def _apply_inline_formatting(self, paragraph, text: str):
        """Parses a line of text for inline markdown and adds formatted runs to the paragraph."""
        # Regex to split by markdown markers, keeping the delimiters
        parts = re.split(r'(\*\*.*?\*\*|\*.*?\*|`.*?`)', text)
        
        severity_map = {
            'ðŸ”´': 'Critical Severity', 'ðŸŸ ': 'High Severity',
            'ðŸŸ¡': 'Medium Severity', 'ðŸ”µ': 'Low Severity'
        }
        
        for part in parts:
            if not part:
                continue
            if part.startswith('**') and part.endswith('**'):
                run = paragraph.add_run(part[2:-2])
                run.bold = True
            elif part.startswith('*') and part.endswith('*'):
                run = paragraph.add_run(part[1:-1])
                run.italic = True
            elif part.startswith('`') and part.endswith('`'):
                run = paragraph.add_run(part[1:-1])
                run.style = 'Code Style' if 'Code Style' in [s.name for s in paragraph.part.document.styles] else 'Default Paragraph Font'
            else:
                # Check for severity indicators
                found_severity = False
                for indicator, style_name in severity_map.items():
                    if indicator in part:
                        # Add text before, the indicator with style, and text after
                        sub_parts = part.split(indicator, 1)
                        paragraph.add_run(sub_parts[0])
                        paragraph.add_run(indicator + ' ', style=style_name)
                        paragraph.add_run(sub_parts[1])
                        found_severity = True
                        break
                if not found_severity:
                    paragraph.add_run(part)

    def _add_table_of_contents(self, doc: Document):
        """Adds a placeholder for the Table of Contents."""
        doc.add_paragraph('Table of Contents', style='Section Heading')
        paragraph = doc.add_paragraph()
        run = paragraph.add_run()
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'begin')
        run._r.append(fldChar)
        
        run = paragraph.add_run()
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'
        run._r.append(instrText)

        run = paragraph.add_run()
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'end')
        run._r.append(fldChar)
        doc.add_paragraph('Note: To update, right-click the table of contents and select "Update Field".', style='Italic')
        doc.add_page_break()

    def _parse_and_add_content(self, doc: Document, markdown_content: str, title: str):
        """Parses markdown content block by block and adds it to the document."""
        # Add Title and TOC first
        doc.add_paragraph(title, style='Report Title')
        self._add_table_of_contents(doc)

        lines = markdown_content.split('\n')
        in_code_block = False
        in_processing_summary = False

        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            if not line:
                i += 1
                continue
            
            # Toggle processing summary section
            if line.startswith('## Processing Summary'):
                in_processing_summary = True
            elif line.startswith('## ') and in_processing_summary:
                in_processing_summary = False
            
            # Headings
            if line.startswith('### '):
                p = doc.add_paragraph(style='Subsection Heading')
                self._apply_inline_formatting(p, line[4:])
            elif line.startswith('## '):
                p = doc.add_paragraph(style='Section Heading')
                self._apply_inline_formatting(p, line[3:])
            elif line.startswith('# '):
                p = doc.add_paragraph(style='Report Title')
                self._apply_inline_formatting(p, line[2:])
            # Lists
            elif line.startswith(('- ', '* ')):
                p = doc.add_paragraph(style='List Bullet')
                self._apply_inline_formatting(p, line[2:])
            # Tables
            elif line.startswith('|') and line.endswith('|'):
                table_lines = []
                while i < len(lines) and lines[i].strip().startswith('|'):
                    table_lines.append(lines[i].strip())
                    i += 1
                self._add_table(doc, table_lines)
                continue # Continue to next loop iteration
            # Horizontal Rule
            elif line.startswith('---'):
                doc.add_paragraph().add_run()._r.append(OxmlElement('w:br'))
            # Regular Paragraphs
            else:
                style = 'Processing Summary' if in_processing_summary else 'Normal'
                p = doc.add_paragraph(style=style)
                self._apply_inline_formatting(p, line)
            
            i += 1
            
    def _add_table(self, doc: Document, table_lines: List[str]):
        """Adds a markdown table to the document."""
        if len(table_lines) < 2: return # Header and separator line needed

        cells_data = [re.split(r'\s*\|\s*', line.strip()[1:-1]) for line in table_lines]
        header = cells_data[0]
        
        table = doc.add_table(rows=1, cols=len(header), style='Table Grid')
        hdr_cells = table.rows[0].cells
        for i, col_name in enumerate(header):
            hdr_cells[i].text = col_name
            hdr_cells[i].paragraphs[0].runs[0].bold = True

        for row_data in cells_data[2:]: # Skip header and separator
            row_cells = table.add_row().cells
            for i, cell_text in enumerate(row_data):
                if i < len(row_cells):
                    row_cells[i].text = cell_text

    def _add_footer(self, doc: Document):
        """Adds a footer with dynamic 'Page X of Y' page numbering."""
        try:
            footer = doc.sections[0].footer
            if not footer.paragraphs:
                footer.add_paragraph()

            p = footer.paragraphs[0]
            p.alignment = WD_ALIGN_PARAGRAPH.RIGHT

            # Helper to add a field to a paragraph
            def add_field(paragraph, field_text):
                run = paragraph.add_run()
                run._r.append(OxmlElement('w:fldChar', {'w:fldCharType': 'begin'}))
                run._r.append(OxmlElement('w:instrText', {'xml:space': 'preserve'}, field_text))
                run._r.append(OxmlElement('w:fldChar', {'w:fldCharType': 'end'}))

            p.text = "YMYL Audit Report | Page "
            add_field(p, 'PAGE')
            p.add_run(' of ')
            add_field(p, 'NUMPAGES')

            # Style the footer text
            for run in p.runs:
                run.font.name = 'Calibri'
                run.font.size = Pt(9)
                run.font.color.rgb = RGBColor(127, 140, 141)

        except Exception as e:
            logger.warning(f"Could not add dynamic footer: {e}")

    def _create_error_document(self, error_message: str) -> bytes:
        """Creates a simple Word document describing an error."""
        try:
            doc = Document()
            doc.add_heading('Report Generation Error', level=1)
            p = doc.add_paragraph()
            p.add_run('An unexpected error occurred while generating the report.\n\n').bold = True
            p.add_run(f"Error details: {error_message}\n\n")
            p.add_run('Please check the input data or contact support.')
            
            doc_buffer = io.BytesIO()
            doc.save(doc_buffer)
            doc_buffer.seek(0)
            return doc_buffer.getvalue()
        except Exception as e:
            logger.critical(f"Fatal: Could not even create the error document: {e}")
            return b"Error: Could not create the Word document due to a critical failure."

    def validate_markdown(self, markdown_content: str) -> bool:
        """Performs basic validation on the markdown content."""
        if not isinstance(markdown_content, str) or not markdown_content.strip():
            logger.warning("Validation failed: Markdown content is empty or not a string.")
            return False
        
        # Check for extremely long content that might cause memory issues
        # Increased limit to 5MB for larger reports
        if len(markdown_content) > 5_000_000:
            logger.warning(f"Markdown content is very large: {len(markdown_content):,} characters.")
        
        return True

    def get_document_info(self, markdown_content: str) -> dict:
        """Extracts basic metadata from the markdown content."""
        if not self.validate_markdown(markdown_content):
            return {'error': 'Invalid markdown content'}
            
        try:
            lines = markdown_content.split('\n')
            char_count = len(markdown_content)
            
            return {
                'total_lines': len(lines),
                'headings': len([l for l in lines if l.strip().startswith('#')]),
                'bullet_points': len([l for l in lines if l.strip().startswith(('* ', '- '))]),
                'tables': markdown_content.count('\n|---'),
                'character_count': char_count,
                'word_count_estimate': len(markdown_content.split()),
                # Estimate: 400 words per page
                'estimated_pages': max(1, len(markdown_content.split()) // 400),
            }
        except Exception as e:
            logger.error(f"Error getting document info: {e}")
            return {'error': str(e)}